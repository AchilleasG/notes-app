{% extends "base.html" %}

{% block title %}{% if note %}Edit Note{% else %}Create Note{% endif %} - Personal Notebook{% endblock %}

{% block extra_css %}
<style>
    .form-container {
        max-width: 900px;
        margin: 0 auto;
    }
    
    .form-container h2 {
        color: var(--text-primary);
        margin-bottom: 24px;
        font-size: 24px;
        font-weight: 600;
    }
    
    @media (min-width: 640px) {
        .form-container h2 {
            font-size: 28px;
        }
    }
    
    .form-group {
        margin-bottom: 20px;
    }
    
    .form-group label {
        display: block;
        color: var(--text-primary);
        font-weight: 500;
        margin-bottom: 8px;
        font-size: 15px;
    }
    
    .form-group input[type="text"],
    .form-group textarea {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        font-size: 16px;
        font-family: inherit;
        transition: all 0.2s ease;
        background: var(--bg-secondary);
        color: var(--text-primary);
    }
    
    .form-group input[type="text"]:focus,
    .form-group textarea:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px var(--accent-light);
    }
    
    .form-group textarea {
        min-height: 400px;
        resize: vertical;
        line-height: 1.6;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Courier New', monospace;
        font-size: 14px;
    }
    
    @media (min-width: 640px) {
        .form-group textarea {
            min-height: 500px;
        }
    }
    
    .form-actions {
        display: flex;
        gap: 8px;
        margin-top: 24px;
        padding-top: 20px;
        border-top: 1px solid var(--border-secondary);
        flex-wrap: wrap;
    }
    
    .form-actions .btn {
        flex: 1;
        min-width: 120px;
    }
    
    @media (min-width: 640px) {
        .form-actions .btn {
            flex: 0;
        }
    }
    
    .checkbox-label {
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        color: var(--text-primary);
        font-weight: 500;
        font-size: 15px;
        padding: 12px;
        background: var(--bg-tertiary);
        border-radius: 8px;
        border: 1px solid var(--border-primary);
        transition: all 0.2s ease;
    }
    
    .checkbox-label:hover {
        border-color: var(--border-hover);
    }
    
    .checkbox-label input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
    }
    
    .markdown-toolbar {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        padding: 8px;
        display: flex;
        gap: 4px;
        flex-wrap: wrap;
    }
    
    .markdown-toolbar button {
        background: var(--bg-secondary);
        border: 1px solid var(--border-primary);
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        color: var(--text-primary);
        transition: all 0.2s;
        font-weight: 500;
        min-height: 36px;
    }
    
    .markdown-toolbar button:hover {
        background: var(--accent-light);
        border-color: var(--accent-primary);
    }
    
    .markdown-toolbar button:active {
        transform: scale(0.95);
    }
    
    .form-group textarea.with-toolbar {
        border-radius: 0 0 8px 8px;
    }
    
    .markdown-guide {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 20px;
        font-size: 14px;
        color: var(--text-secondary);
    }
    
    .markdown-guide h3 {
        margin: 0 0 12px 0;
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 600;
    }
    
    .markdown-guide code {
        background: var(--bg-secondary);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Courier New', monospace;
        font-size: 13px;
        color: var(--accent-primary);
    }
    
    .markdown-guide ul {
        margin: 0;
        padding-left: 20px;
    }
    
    .markdown-guide li {
        margin-bottom: 6px;
        line-height: 1.5;
    }
    
    .toggle-guide {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        color: var(--text-primary);
        cursor: pointer;
        font-size: 14px;
        padding: 10px 16px;
        margin-bottom: 12px;
        font-weight: 500;
        border-radius: 8px;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 6px;
    }
    
    .toggle-guide:hover {
        background: var(--border-secondary);
    }
    
    .form-group input[type="password"] {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        font-size: 16px;
        transition: all 0.2s ease;
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-family: inherit;
    }
    
    .form-group input[type="password"]:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px var(--accent-light);
    }
    
    .form-group small {
        color: var(--text-secondary);
        font-size: 13px;
        display: block;
        margin-top: 6px;
        line-height: 1.5;
    }
    
    .file-upload-group {
        margin-top: 12px;
        padding: 12px;
        background: var(--bg-tertiary);
        border-radius: 8px;
        border: 1px dashed var(--border-primary);
    }
    
    .file-upload-group label {
        font-size: 14px;
        margin-bottom: 8px;
    }
    
    .file-upload-group input[type="file"] {
        display: block;
        width: 100%;
        padding: 8px;
        font-size: 14px;
        color: var(--text-primary);
    }
    
    .file-upload-hint {
        font-size: 13px;
        color: var(--text-tertiary);
        margin-top: 8px;
    }
</style>
{% endblock %}

{% block content %}
<div class="form-container">
    <h2>{% if note %}Edit Note{% else %}Create New Note{% endif %}</h2>
    
    <button type="button" class="toggle-guide" onclick="toggleGuide()">
        <span id="guideIcon">üìñ</span> Markdown Guide
    </button>
    <div id="markdownGuide" class="markdown-guide" style="display: none;">
        <h3>Markdown Formatting Guide</h3>
        <ul>
            <li><strong>Headers:</strong> <code># H1</code>, <code>## H2</code>, <code>### H3</code></li>
            <li><strong>Bold:</strong> <code>**bold text**</code></li>
            <li><strong>Italic:</strong> <code>*italic text*</code></li>
            <li><strong>Bullet List:</strong> <code>- Item</code> or <code>* Item</code></li>
            <li><strong>Numbered List:</strong> <code>1. Item</code></li>
            <li><strong>Checkbox:</strong> <code>- [ ] Unchecked</code>, <code>- [x] Checked</code></li>
            <li><strong>Link:</strong> <code>[text](url)</code></li>
            <li><strong>Image:</strong> <code>![alt text](url)</code></li>
            <li><strong>Code:</strong> <code>`inline code`</code> or <code>```code block```</code></li>
        </ul>
    </div>
    
    <form method="post" id="noteForm" enctype="multipart/form-data">
        {% csrf_token %}
        <div class="form-group">
            <label for="title">Title</label>
            <input type="text" id="title" name="title" value="{{ note.title|default:'' }}" required placeholder="Enter note title...">
        </div>
        <div class="form-group">
            <label for="content">Content</label>
            <div class="markdown-toolbar">
                <button type="button" onclick="insertMarkdown('**', '**')" title="Bold"><strong>B</strong></button>
                <button type="button" onclick="insertMarkdown('*', '*')" title="Italic"><em>I</em></button>
                <button type="button" onclick="insertMarkdown('# ', '')" title="Heading">H1</button>
                <button type="button" onclick="insertMarkdown('## ', '')" title="Heading 2">H2</button>
                <button type="button" onclick="insertMarkdown('- ', '')" title="Bullet point">‚Ä¢ List</button>
                <button type="button" onclick="insertMarkdown('- [ ] ', '')" title="Checkbox">‚òê Task</button>
                <button type="button" onclick="insertMarkdown('[', '](url)')" title="Link">üîó Link</button>
                <button type="button" onclick="insertMarkdown('`', '`')" title="Code">&lt;/&gt;</button>
            </div>
            <textarea id="content" name="content" class="with-toolbar" required placeholder="Write your note in Markdown format...">{% if note and not note.is_locked %}{{ note.content }}{% endif %}</textarea>
        </div>
        {% if not note or not note.is_locked %}
        <div class="form-group">
            <label class="checkbox-label">
                <input type="checkbox" id="is_locked" name="is_locked" {% if is_locked %}checked{% endif %}>
                <span>üîí Encrypt this note with a password</span>
            </label>
        </div>
        <div class="form-group" id="passwordGroup" style="display: {% if is_locked %}block{% else %}none{% endif %};">
            <label for="lock_password">Encryption Password</label>
            <input type="password" id="lock_password" name="lock_password" placeholder="Enter a strong password">
            <small>
                This password will encrypt your note. You'll need it to view the note later. Make sure to remember it!
            </small>
        </div>
        {% endif %}
        <div class="form-actions">
            <button type="submit" class="btn btn-primary">{% if note %}üíæ Save Changes{% else %}‚úì Create Note{% endif %}</button>
            <a href="{% if note %}{% url 'note_view' note.pk %}{% else %}{% url 'note_list' %}{% endif %}" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

<script>
    // Toggle markdown guide
    function toggleGuide() {
        const guide = document.getElementById('markdownGuide');
        const btn = document.querySelector('.toggle-guide');
        if (guide.style.display === 'none') {
            guide.style.display = 'block';
            btn.innerHTML = '<span id="guideIcon">üìñ</span> Hide Guide';
        } else {
            guide.style.display = 'none';
            btn.innerHTML = '<span id="guideIcon">üìñ</span> Markdown Guide';
        }
    }
    
    // Insert markdown syntax
    function insertMarkdown(before, after, placeholder = '') {
        const textarea = document.getElementById('content');
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selectedText = textarea.value.substring(start, end);
        const newText = before + (selectedText || placeholder) + after;
        
        textarea.value = textarea.value.substring(0, start) + newText + textarea.value.substring(end);
        
        // Set cursor position
        const newCursorPos = start + before.length + (selectedText ? selectedText.length : placeholder.length);
        textarea.setSelectionRange(newCursorPos, newCursorPos);
        textarea.focus();
    }
    
    // Auto-continue lists on Enter key
    const contentTextarea = document.getElementById('content');
    contentTextarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            const start = this.selectionStart;
            const text = this.value;
            
            // Find the start of the current line
            const lineStart = text.lastIndexOf('\n', start - 1) + 1;
            const currentLine = text.substring(lineStart, start);
            
            // Check for checkbox list FIRST (- [ ] or - [x]) - must come before bullet check
            const checkboxMatch = currentLine.match(/^(\s*-\s+\[[ xX]\]\s+)/);
            if (checkboxMatch) {
                e.preventDefault();
                const indentation = currentLine.match(/^(\s*)/)[1];
                // Check if the line is empty (just the checkbox)
                if (currentLine.trim() === '- [ ]' || currentLine.trim() === '- [x]' || currentLine.trim() === '- [X]') {
                    // Remove the empty checkbox and don't add a new one
                    const newText = text.substring(0, lineStart) + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = lineStart;
                } else {
                    // Add a new unchecked checkbox
                    const prefix = indentation + '- [ ] ';
                    const newText = text.substring(0, start) + '\n' + prefix + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = start + 1 + prefix.length;
                }
                return;
            }
            
            // Check for bullet list (- or *)
            const bulletMatch = currentLine.match(/^(\s*[-*]\s+)/);
            if (bulletMatch) {
                e.preventDefault();
                const prefix = bulletMatch[1];
                // Check if the line is empty (just the bullet)
                if (currentLine.trim() === '-' || currentLine.trim() === '*') {
                    // Remove the empty bullet and don't add a new one
                    const newText = text.substring(0, lineStart) + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = lineStart;
                } else {
                    // Add a new bullet point
                    const newText = text.substring(0, start) + '\n' + prefix + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = start + 1 + prefix.length;
                }
                return;
            }
            
            // Check for numbered list
            const numberedMatch = currentLine.match(/^(\s*)(\d+)\.\s+/);
            if (numberedMatch) {
                e.preventDefault();
                const indentation = numberedMatch[1];
                const currentNum = parseInt(numberedMatch[2]);
                // Check if the line is empty (just the number)
                if (currentLine.trim() === `${currentNum}.`) {
                    // Remove the empty number and don't add a new one
                    const newText = text.substring(0, lineStart) + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = lineStart;
                } else {
                    // Add a new numbered item
                    const nextNum = currentNum + 1;
                    const prefix = indentation + nextNum + '. ';
                    const newText = text.substring(0, start) + '\n' + prefix + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = start + 1 + prefix.length;
                }
                return;
            }
        }
    });
    
    // Lock checkbox handler
    const isLockedCheckbox = document.getElementById('is_locked');
    if (isLockedCheckbox) {
        isLockedCheckbox.addEventListener('change', function() {
            document.getElementById('passwordGroup').style.display = this.checked ? 'block' : 'none';
            document.getElementById('lock_password').required = this.checked;
        });
    }

    // Client-side encryption
    class NoteEncryption {
        constructor() {
            this.algorithm = 'AES-GCM';
            this.keyLength = 256;
            this.ivLength = 12;
            this.saltLength = 16;
            this.iterations = 100000;
        }

        generateSalt() {
            return crypto.getRandomValues(new Uint8Array(this.saltLength));
        }

        generateIV() {
            return crypto.getRandomValues(new Uint8Array(this.ivLength));
        }

        async deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );

            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: this.iterations,
                    hash: 'SHA-256'
                },
                passwordKey,
                {
                    name: this.algorithm,
                    length: this.keyLength
                },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async encrypt(text, password, existingSalt = null) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                
                // Use existing salt if provided, otherwise generate new one
                const salt = existingSalt ? new Uint8Array(existingSalt.match(/.{2}/g).map(byte => parseInt(byte, 16))) : this.generateSalt();
                const iv = this.generateIV();
                const key = await this.deriveKey(password, salt);

                const encryptedData = await crypto.subtle.encrypt(
                    {
                        name: this.algorithm,
                        iv: iv
                    },
                    key,
                    data
                );

                // Combine only iv + encrypted data (salt stored separately)
                const result = new Uint8Array(iv.length + encryptedData.byteLength);
                result.set(iv, 0);
                result.set(new Uint8Array(encryptedData), iv.length);

                return {
                    encrypted: btoa(String.fromCharCode(...result)),
                    salt: Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('')
                };
            } catch (error) {
                console.error('Encryption failed:', error);
                throw new Error('Failed to encrypt content');
            }
        }

        async decrypt(encryptedText, password, saltHex) {
            try {
                // Convert base64 back to bytes
                const combined = new Uint8Array(atob(encryptedText).split('').map(c => c.charCodeAt(0)));
                
                // Extract salt from hex (stored separately in database)
                const salt = new Uint8Array(saltHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
                
                // Try to determine the format based on the length
                let iv, encryptedData;
                
                if (combined.length >= this.saltLength + this.ivLength) {
                    // Check if this might be the old format (salt + iv + data)
                    // Extract the first saltLength bytes and see if they match our stored salt
                    const embeddedSalt = combined.slice(0, this.saltLength);
                    const saltMatches = Array.from(embeddedSalt).every((byte, i) => byte === salt[i]);
                    
                    if (saltMatches) {
                        // Old format: salt + iv + encrypted data
                        console.log('Detected old format with embedded salt');
                        iv = combined.slice(this.saltLength, this.saltLength + this.ivLength);
                        encryptedData = combined.slice(this.saltLength + this.ivLength);
                    } else {
                        // New format: iv + encrypted data
                        console.log('Detected new format without embedded salt');
                        iv = combined.slice(0, this.ivLength);
                        encryptedData = combined.slice(this.ivLength);
                    }
                } else {
                    // New format: iv + encrypted data
                    console.log('Detected new format based on length');
                    iv = combined.slice(0, this.ivLength);
                    encryptedData = combined.slice(this.ivLength);
                }

                const key = await this.deriveKey(password, salt);

                const decryptedData = await crypto.subtle.decrypt(
                    {
                        name: this.algorithm,
                        iv: iv
                    },
                    key,
                    encryptedData
                );

                const decoder = new TextDecoder();
                return decoder.decode(decryptedData);
            } catch (error) {
                console.error('Decryption failed:', error);
                throw new Error('Failed to decrypt content - wrong password?');
            }
        }

        cachePassword(noteId, password) {
            this.passwordCache = this.passwordCache || new Map();
            this.passwordCache.set(noteId, password);
        }

        getCachedPassword(noteId) {
            this.passwordCache = this.passwordCache || new Map();
            return this.passwordCache.get(noteId);
        }
    }

    const noteEncryption = new NoteEncryption();

    // Handle form submission with encryption
    document.getElementById('noteForm').addEventListener('submit', async function(e) {
        const isLocked = document.getElementById('is_locked');
        const password = document.getElementById('lock_password');
        const content = document.getElementById('content');
        
        // Check if we're editing a locked note (password stored in dataset)
        const editingLockedNote = content.dataset.notePassword;
        const existingSalt = content.dataset.noteSalt;
        
        // Determine if we need to encrypt
        const needsEncryption = (isLocked && isLocked.checked && password && password.value) || editingLockedNote;
        
        if (needsEncryption) {
            e.preventDefault(); // Stop the normal form submission
            
            try {
                // Use the password from the lock field if locking now, otherwise use cached password for editing
                const encryptPassword = (password && password.value) ? password.value : editingLockedNote;
                
                // Encrypt the content - reuse existing salt if editing a locked note
                const result = await noteEncryption.encrypt(content.value, encryptPassword, existingSalt || null);
                
                // Create hidden fields for encrypted data
                let encryptedContentField = document.getElementById('encrypted_content');
                let saltField = document.getElementById('salt_field');
                let isLockedField = document.getElementById('is_locked_field');
                
                if (!encryptedContentField) {
                    encryptedContentField = document.createElement('input');
                    encryptedContentField.type = 'hidden';
                    encryptedContentField.name = 'encrypted_content';
                    encryptedContentField.id = 'encrypted_content';
                    this.appendChild(encryptedContentField);
                }
                
                if (!saltField) {
                    saltField = document.createElement('input');
                    saltField.type = 'hidden';
                    saltField.name = 'salt';
                    saltField.id = 'salt_field';
                    this.appendChild(saltField);
                }
                
                if (editingLockedNote && !isLocked) {
                    // When editing an already locked note, ensure is_locked stays true
                    if (!isLockedField) {
                        isLockedField = document.createElement('input');
                        isLockedField.type = 'hidden';
                        isLockedField.name = 'is_locked';
                        isLockedField.id = 'is_locked_field';
                        isLockedField.value = 'on';
                        this.appendChild(isLockedField);
                    }
                }
                
                // Set the encrypted values
                encryptedContentField.value = result.encrypted;
                saltField.value = result.salt;
                
                // Clear the original content field (we'll send encrypted instead)
                content.value = '';
                
                // Clear the password field (don't send password to server)
                if (password) {
                    password.value = '';
                }
                
                // Now submit the form
                this.submit();
            } catch (error) {
                alert('Encryption failed: ' + error.message);
            }
        }
        // If not locked or no password, submit normally
    });

    // Handle editing locked notes - decrypt content on page load
    {% if note and note.is_locked %}
    (async function() {
        const noteData = {
            id: {{ note.pk }},
            content: '{{ note.content }}',
            salt: '{{ note.salt }}',
            is_locked: {{ note.is_locked|lower }}
        };

        // Check if we have a cached password for this note
        const cachedPassword = noteEncryption.getCachedPassword(noteData.id);
        
        if (cachedPassword) {
            try {
                const decryptedContent = await noteEncryption.decrypt(
                    noteData.content,
                    cachedPassword,
                    noteData.salt
                );
                document.getElementById('content').value = decryptedContent;
                // Store the password and salt for re-encryption
                document.getElementById('content').dataset.notePassword = cachedPassword;
                document.getElementById('content').dataset.noteSalt = noteData.salt;
            } catch (error) {
                console.error('Failed to decrypt with cached password:', error);
                // Password might have expired or be wrong, prompt for new one
                promptForPassword();
            }
        } else {
            // No cached password, prompt for it
            promptForPassword();
        }

        async function promptForPassword() {
            const password = prompt('This note is locked. Please enter the password to edit it:');
            if (password) {
                try {
                    const decryptedContent = await noteEncryption.decrypt(
                        noteData.content,
                        password,
                        noteData.salt
                    );
                    document.getElementById('content').value = decryptedContent;
                    // Cache the password for this session
                    noteEncryption.cachePassword(noteData.id, password);
                    
                    // Store the password and salt temporarily for re-encryption
                    document.getElementById('content').dataset.notePassword = password;
                    document.getElementById('content').dataset.noteSalt = noteData.salt;
                } catch (error) {
                    alert('Decryption failed. Wrong password?');
                    window.location.href = '{% url "note_view" note.pk %}';
                }
            } else {
                // User cancelled, redirect back to view
                window.location.href = '{% url "note_view" note.pk %}';
            }
        }
    })();
    {% endif %}
</script>
{% endblock %}
