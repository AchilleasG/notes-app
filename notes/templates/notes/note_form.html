{% extends "base.html" %}

{% block title %}{% if note %}Edit Note{% else %}Create Note{% endif %} - Personal Notebook{% endblock %}

{% block extra_css %}
<style>
    .form-container {
        max-width: 900px;
        margin: 0 auto;
    }
    
    .form-container h2 {
        color: var(--text-primary);
        margin-bottom: 24px;
        font-size: 24px;
        font-weight: 600;
    }
    
    @media (min-width: 640px) {
        .form-container h2 {
            font-size: 28px;
        }
    }
    
    .form-group {
        margin-bottom: 20px;
    }
    
    .form-group label {
        display: block;
        color: var(--text-primary);
        font-weight: 500;
        margin-bottom: 8px;
        font-size: 15px;
    }
    
    .form-group input[type="text"],
    .form-group textarea {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        font-size: 16px;
        font-family: inherit;
        transition: all 0.2s ease;
        background: var(--bg-secondary);
        color: var(--text-primary);
    }
    
    .form-group input[type="text"]:focus,
    .form-group textarea:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px var(--accent-light);
    }
    
    .form-group textarea {
        min-height: 400px;
        resize: vertical;
        line-height: 1.6;
        font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 14px;
    }
    
    @media (min-width: 640px) {
        .form-group textarea {
            min-height: 500px;
        }
    }
    
    .form-actions {
        display: flex;
        gap: 8px;
        margin-top: 24px;
        padding-top: 20px;
        border-top: 1px solid var(--border-secondary);
        flex-wrap: wrap;
    }
    
    .form-actions .btn {
        flex: 1;
        min-width: 120px;
    }
    
    @media (min-width: 640px) {
        .form-actions .btn {
            flex: 0;
        }
    }
    
    .checkbox-label {
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        color: var(--text-primary);
        font-weight: 500;
        font-size: 15px;
        padding: 12px;
        background: var(--bg-tertiary);
        border-radius: 8px;
        border: 1px solid var(--border-primary);
        transition: all 0.2s ease;
    }
    
    .checkbox-label:hover {
        border-color: var(--border-hover);
    }
    
    .checkbox-label input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
    }
    
    .markdown-toolbar {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        padding: 8px;
        display: flex;
        gap: 4px;
        flex-wrap: wrap;
    }
    
    .markdown-toolbar button {
        background: var(--bg-secondary);
        border: 1px solid var(--border-primary);
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        color: var(--text-primary);
        transition: all 0.2s;
        font-weight: 500;
        min-height: 36px;
    }
    
    .markdown-toolbar button:hover {
        background: var(--accent-light);
        border-color: var(--accent-primary);
    }
    
    .markdown-toolbar button:active {
        transform: scale(0.95);
    }
    
    .form-group textarea.with-toolbar {
        border-radius: 0 0 8px 8px;
    }
    
    .markdown-guide {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 20px;
        font-size: 14px;
        color: var(--text-secondary);
    }
    
    .markdown-guide h3 {
        margin: 0 0 12px 0;
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 600;
    }
    
    .markdown-guide code {
        background: var(--bg-secondary);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 13px;
        color: var(--accent-primary);
    }
    
    .markdown-guide ul {
        margin: 0;
        padding-left: 20px;
    }
    
    .markdown-guide li {
        margin-bottom: 6px;
        line-height: 1.5;
    }
    
    .toggle-guide {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        color: var(--text-primary);
        cursor: pointer;
        font-size: 14px;
        padding: 10px 16px;
        margin-bottom: 12px;
        font-weight: 500;
        border-radius: 8px;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 6px;
    }
    
    .toggle-guide:hover {
        background: var(--border-secondary);
    }
    
    .form-group input[type="password"] {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        font-size: 16px;
        transition: all 0.2s ease;
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-family: inherit;
    }
    
    .form-group input[type="password"]:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px var(--accent-light);
    }
    
    .form-group small {
        color: var(--text-secondary);
        font-size: 13px;
        display: block;
        margin-top: 6px;
        line-height: 1.5;
    }
    
    .file-upload-group {
        margin-top: 12px;
        padding: 12px;
        background: var(--bg-tertiary);
        border-radius: 8px;
        border: 1px dashed var(--border-primary);
    }
    
    .file-upload-group label {
        font-size: 14px;
        margin-bottom: 8px;
    }
    
    .file-upload-group input[type="file"] {
        display: block;
        width: 100%;
        padding: 8px;
        font-size: 14px;
        color: var(--text-primary);
    }
    
    .file-upload-hint {
        font-size: 13px;
        color: var(--text-tertiary);
        margin-top: 8px;
    }
    
    /* Tags styling */
    .tags-container {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
        min-height: 32px;
        padding: 8px;
        background: var(--bg-tertiary);
        border-radius: 8px;
        border: 1px solid var(--border-primary);
    }
    
    .tag-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 13px;
        font-weight: 500;
        color: white;
        cursor: default;
        transition: all 0.2s ease;
    }
    
    .tag-badge:hover {
        opacity: 0.9;
    }
    
    .tag-remove {
        cursor: pointer;
        font-size: 16px;
        line-height: 1;
        opacity: 0.8;
        transition: opacity 0.2s;
    }
    
    .tag-remove:hover {
        opacity: 1;
    }
    
    .tags-input-wrapper {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    
    #tags-input {
        flex: 1;
        padding: 10px 12px;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        font-size: 14px;
        background: var(--bg-secondary);
        color: var(--text-primary);
        transition: all 0.2s ease;
    }
    
    #tags-input:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px var(--accent-light);
    }
    
    #tag-color {
        width: 50px;
        height: 38px;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        cursor: pointer;
        background: var(--bg-secondary);
    }
    
    .tags-autocomplete {
        position: relative;
        margin-top: 4px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        box-shadow: 0 4px 12px var(--shadow-md);
        max-height: 200px;
        overflow-y: auto;
        z-index: 1000;
    }
    
    .tag-suggestion {
        padding: 10px 12px;
        cursor: pointer;
        transition: background 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .tag-suggestion:hover,
    .tag-suggestion.selected {
        background: var(--bg-tertiary);
    }
    
    .tag-suggestion-color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 1px solid var(--border-primary);
    }
    
    .tag-suggestion-name {
        color: var(--text-primary);
        font-size: 14px;
    }
</style>
{% endblock %}

{% block content %}
<div class="form-container">
    <h2>{% if note %}Edit Note{% else %}Create New Note{% endif %}</h2>
    
    <button type="button" class="toggle-guide" onclick="toggleGuide()">
        <span id="guideIcon">üìñ</span> Markdown Guide
    </button>
    <div id="markdownGuide" class="markdown-guide" style="display: none;">
        <h3>Markdown Formatting Guide</h3>
        <ul>
            <li><strong>Headers:</strong> <code># H1</code>, <code>## H2</code>, <code>### H3</code></li>
            <li><strong>Bold:</strong> <code>**bold text**</code></li>
            <li><strong>Italic:</strong> <code>*italic text*</code></li>
            <li><strong>Bullet List:</strong> <code>- Item</code> or <code>* Item</code></li>
            <li><strong>Numbered List:</strong> <code>1. Item</code></li>
            <li><strong>Checkbox:</strong> <code>- [ ] Unchecked</code>, <code>- [x] Checked</code></li>
            <li><strong>Link:</strong> <code>[text](url)</code></li>
            <li><strong>Image:</strong> <code>![alt text](url)</code></li>
            <li><strong>Code:</strong> <code>`inline code`</code> or <code>```code block```</code></li>
        </ul>
    </div>
    
    <form method="post" id="noteForm" enctype="multipart/form-data">
        {% csrf_token %}
        <div class="form-group">
            <label for="title">Title</label>
            <input type="text" id="title" name="title" value="{{ note.title|default:'' }}" required placeholder="Enter note title...">
        </div>
        <div class="form-group">
            <label for="content">Content</label>
            <div class="markdown-toolbar">
                <button type="button" onclick="insertMarkdown('**', '**')" title="Bold"><strong>B</strong></button>
                <button type="button" onclick="insertMarkdown('*', '*')" title="Italic"><em>I</em></button>
                <button type="button" onclick="insertMarkdown('# ', '')" title="Heading">H1</button>
                <button type="button" onclick="insertMarkdown('## ', '')" title="Heading 2">H2</button>
                <button type="button" onclick="insertMarkdown('- ', '')" title="Bullet point">‚Ä¢ List</button>
                <button type="button" onclick="insertMarkdown('- [ ] ', '')" title="Checkbox">‚òê Task</button>
                <button type="button" onclick="insertMarkdown('[', '](url)')" title="Link">üîó Link</button>
                <button type="button" onclick="insertMarkdown('`', '`')" title="Code">&lt;/&gt;</button>
            </div>
            <textarea id="content" name="content" class="with-toolbar" required placeholder="Write your note in Markdown format...">{% if note and not note.is_locked %}{{ note.content }}{% endif %}</textarea>
        </div>
        
        <div class="form-group">
            <label for="tags-input">Tags</label>
            <div id="tags-container" class="tags-container"></div>
            <div class="tags-input-wrapper">
                <input type="text" id="tags-input" placeholder="Type to add tags... (press Enter or comma)" autocomplete="off">
                <input type="color" id="tag-color" value="#3b82f6" title="Tag color">
            </div>
            <div id="tags-autocomplete" class="tags-autocomplete" style="display: none;"></div>
            <input type="hidden" id="tags-data" name="tags">
        </div>
        
        {% if not note or not note.is_locked %}
        <div class="form-group">
            <label class="checkbox-label">
                <input type="checkbox" id="is_locked" name="is_locked" {% if is_locked %}checked{% endif %}>
                <span>üîí Encrypt this note with a password</span>
            </label>
        </div>
        <div class="form-group" id="passwordGroup" style="display: {% if is_locked %}block{% else %}none{% endif %};">
            <label for="lock_password">Encryption Password</label>
            <input type="password" id="lock_password" name="lock_password" placeholder="Enter a strong password">
            <small>
                This password will encrypt your note. You'll need it to view the note later. Make sure to remember it!
            </small>
        </div>
        {% endif %}
        <div class="form-actions">
            <button type="submit" class="btn btn-primary">{% if note %}üíæ Save Changes{% else %}‚úì Create Note{% endif %}</button>
            <a href="{% if note %}{% url 'note_view' note.pk %}{% else %}{% url 'note_list' %}{% endif %}" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

<script>
    // Toggle markdown guide
    function toggleGuide() {
        const guide = document.getElementById('markdownGuide');
        const btn = document.querySelector('.toggle-guide');
        if (guide.style.display === 'none') {
            guide.style.display = 'block';
            btn.innerHTML = '<span id="guideIcon">üìñ</span> Hide Guide';
        } else {
            guide.style.display = 'none';
            btn.innerHTML = '<span id="guideIcon">üìñ</span> Markdown Guide';
        }
    }
    
    // Insert markdown syntax with toggle support
    function insertMarkdown(before, after, placeholder = '') {
        const textarea = document.getElementById('content');
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const text = textarea.value;
        const selectedText = text.substring(start, end);
        
        // Check if we're undoing - look for the markdown syntax right before cursor
        const beforeText = text.substring(Math.max(0, start - before.length), start);
        const afterText = text.substring(end, end + after.length);
        
        // If the markdown syntax is already there and nothing is selected, remove it (toggle off)
        if (beforeText === before && afterText === after && selectedText === placeholder) {
            // Remove the markdown syntax
            textarea.value = text.substring(0, start - before.length) + text.substring(end + after.length);
            textarea.setSelectionRange(start - before.length, start - before.length);
            textarea.focus();
            return;
        }
        
        // Otherwise, insert the markdown syntax (toggle on)
        const newText = before + (selectedText || placeholder) + after;
        textarea.value = text.substring(0, start) + newText + text.substring(end);
        
        // Set cursor position
        const newCursorPos = start + before.length + (selectedText ? selectedText.length : placeholder.length);
        textarea.setSelectionRange(newCursorPos, newCursorPos);
        textarea.focus();
        
        // Store the insertion info for backspace handling
        textarea.dataset.lastInsert = JSON.stringify({
            start: start,
            before: before,
            after: after,
            placeholder: placeholder,
            cursorPos: newCursorPos
        });
    }
    
    // Auto-continue lists on Enter key and handle backspace for markdown insertions
    const contentTextarea = document.getElementById('content');
    contentTextarea.addEventListener('keydown', function(e) {
        // Handle Backspace for undoing markdown insertions
        if (e.key === 'Backspace' && this.dataset.lastInsert) {
            try {
                const lastInsert = JSON.parse(this.dataset.lastInsert);
                const currentPos = this.selectionStart;
                
                // Check if cursor is still at the position right after the insertion
                if (currentPos === lastInsert.cursorPos && this.selectionStart === this.selectionEnd) {
                    const text = this.value;
                    const insertStart = lastInsert.start;
                    const insertEnd = lastInsert.cursorPos + lastInsert.after.length;
                    
                    // Verify the markdown syntax is still there
                    const beforePart = text.substring(insertStart, insertStart + lastInsert.before.length);
                    const afterPart = text.substring(lastInsert.cursorPos, insertEnd);
                    
                    if (beforePart === lastInsert.before && afterPart === lastInsert.after) {
                        e.preventDefault();
                        // Remove the entire markdown insertion
                        this.value = text.substring(0, insertStart) + lastInsert.placeholder + text.substring(insertEnd);
                        this.setSelectionRange(insertStart + lastInsert.placeholder.length, insertStart + lastInsert.placeholder.length);
                        delete this.dataset.lastInsert;
                        return;
                    }
                }
            } catch (error) {
                // If parsing fails, just continue with normal backspace
            }
        }
        
        // Clear lastInsert on any other key press
        if (e.key !== 'Backspace' && this.dataset.lastInsert) {
            delete this.dataset.lastInsert;
        }
        
        if (e.key === 'Enter') {
            const start = this.selectionStart;
            const text = this.value;
            
            // Find the start of the current line
            const lineStart = text.lastIndexOf('\n', start - 1) + 1;
            const currentLine = text.substring(lineStart, start);
            
            // Check for checkbox list FIRST (- [ ] or - [x]) - must come before bullet check
            const checkboxMatch = currentLine.match(/^(\s*-\s+\[[ xX]\]\s+)/);
            if (checkboxMatch) {
                e.preventDefault();
                const indentation = currentLine.match(/^(\s*)/)[1];
                // Check if the line is empty (just the checkbox)
                if (currentLine.trim() === '- [ ]' || currentLine.trim() === '- [x]' || currentLine.trim() === '- [X]') {
                    // Remove the empty checkbox and don't add a new one
                    const newText = text.substring(0, lineStart) + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = lineStart;
                } else {
                    // Add a new unchecked checkbox
                    const prefix = indentation + '- [ ] ';
                    const newText = text.substring(0, start) + '\n' + prefix + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = start + 1 + prefix.length;
                }
                return;
            }
            
            // Check for bullet list (- or *)
            const bulletMatch = currentLine.match(/^(\s*[-*]\s+)/);
            if (bulletMatch) {
                e.preventDefault();
                const prefix = bulletMatch[1];
                // Check if the line is empty (just the bullet)
                if (currentLine.trim() === '-' || currentLine.trim() === '*') {
                    // Remove the empty bullet and don't add a new one
                    const newText = text.substring(0, lineStart) + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = lineStart;
                } else {
                    // Add a new bullet point
                    const newText = text.substring(0, start) + '\n' + prefix + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = start + 1 + prefix.length;
                }
                return;
            }
            
            // Check for numbered list
            const numberedMatch = currentLine.match(/^(\s*)(\d+)\.\s+/);
            if (numberedMatch) {
                e.preventDefault();
                const indentation = numberedMatch[1];
                const currentNum = parseInt(numberedMatch[2]);
                // Check if the line is empty (just the number)
                if (currentLine.trim() === `${currentNum}.`) {
                    // Remove the empty number and don't add a new one
                    const newText = text.substring(0, lineStart) + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = lineStart;
                } else {
                    // Add a new numbered item
                    const nextNum = currentNum + 1;
                    const prefix = indentation + nextNum + '. ';
                    const newText = text.substring(0, start) + '\n' + prefix + text.substring(start);
                    this.value = newText;
                    this.selectionStart = this.selectionEnd = start + 1 + prefix.length;
                }
                return;
            }
        }
    });
    
    // Lock checkbox handler
    const isLockedCheckbox = document.getElementById('is_locked');
    if (isLockedCheckbox) {
        isLockedCheckbox.addEventListener('change', function() {
            document.getElementById('passwordGroup').style.display = this.checked ? 'block' : 'none';
            document.getElementById('lock_password').required = this.checked;
        });
    }

    // Client-side encryption
    class NoteEncryption {
        constructor() {
            this.algorithm = 'AES-GCM';
            this.keyLength = 256;
            this.ivLength = 12;
            this.saltLength = 16;
            this.iterations = 100000;
        }

        generateSalt() {
            return crypto.getRandomValues(new Uint8Array(this.saltLength));
        }

        generateIV() {
            return crypto.getRandomValues(new Uint8Array(this.ivLength));
        }

        async deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );

            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: this.iterations,
                    hash: 'SHA-256'
                },
                passwordKey,
                {
                    name: this.algorithm,
                    length: this.keyLength
                },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async encrypt(text, password, existingSalt = null) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                
                // Use existing salt if provided, otherwise generate new one
                const salt = existingSalt ? new Uint8Array(existingSalt.match(/.{2}/g).map(byte => parseInt(byte, 16))) : this.generateSalt();
                const iv = this.generateIV();
                const key = await this.deriveKey(password, salt);

                const encryptedData = await crypto.subtle.encrypt(
                    {
                        name: this.algorithm,
                        iv: iv
                    },
                    key,
                    data
                );

                // Combine only iv + encrypted data (salt stored separately)
                const result = new Uint8Array(iv.length + encryptedData.byteLength);
                result.set(iv, 0);
                result.set(new Uint8Array(encryptedData), iv.length);

                return {
                    encrypted: btoa(String.fromCharCode(...result)),
                    salt: Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('')
                };
            } catch (error) {
                console.error('Encryption failed:', error);
                throw new Error('Failed to encrypt content');
            }
        }

        async decrypt(encryptedText, password, saltHex) {
            try {
                // Convert base64 back to bytes
                const combined = new Uint8Array(atob(encryptedText).split('').map(c => c.charCodeAt(0)));
                
                // Extract salt from hex (stored separately in database)
                const salt = new Uint8Array(saltHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
                
                // Try to determine the format based on the length
                let iv, encryptedData;
                
                if (combined.length >= this.saltLength + this.ivLength) {
                    // Check if this might be the old format (salt + iv + data)
                    // Extract the first saltLength bytes and see if they match our stored salt
                    const embeddedSalt = combined.slice(0, this.saltLength);
                    const saltMatches = Array.from(embeddedSalt).every((byte, i) => byte === salt[i]);
                    
                    if (saltMatches) {
                        // Old format: salt + iv + encrypted data
                        console.log('Detected old format with embedded salt');
                        iv = combined.slice(this.saltLength, this.saltLength + this.ivLength);
                        encryptedData = combined.slice(this.saltLength + this.ivLength);
                    } else {
                        // New format: iv + encrypted data
                        console.log('Detected new format without embedded salt');
                        iv = combined.slice(0, this.ivLength);
                        encryptedData = combined.slice(this.ivLength);
                    }
                } else {
                    // New format: iv + encrypted data
                    console.log('Detected new format based on length');
                    iv = combined.slice(0, this.ivLength);
                    encryptedData = combined.slice(this.ivLength);
                }

                const key = await this.deriveKey(password, salt);

                const decryptedData = await crypto.subtle.decrypt(
                    {
                        name: this.algorithm,
                        iv: iv
                    },
                    key,
                    encryptedData
                );

                const decoder = new TextDecoder();
                return decoder.decode(decryptedData);
            } catch (error) {
                console.error('Decryption failed:', error);
                throw new Error('Failed to decrypt content - wrong password?');
            }
        }

        cachePassword(noteId, password) {
            this.passwordCache = this.passwordCache || new Map();
            this.passwordCache.set(noteId, password);
        }

        getCachedPassword(noteId) {
            this.passwordCache = this.passwordCache || new Map();
            return this.passwordCache.get(noteId);
        }
    }

    const noteEncryption = new NoteEncryption();

    // Handle form submission with encryption
    document.getElementById('noteForm').addEventListener('submit', async function(e) {
        const isLocked = document.getElementById('is_locked');
        const password = document.getElementById('lock_password');
        const content = document.getElementById('content');
        
        // Check if we're editing a locked note (password stored in dataset)
        const editingLockedNote = content.dataset.notePassword;
        const existingSalt = content.dataset.noteSalt;
        
        // Determine if we need to encrypt
        const needsEncryption = (isLocked && isLocked.checked && password && password.value) || editingLockedNote;
        
        if (needsEncryption) {
            e.preventDefault(); // Stop the normal form submission
            
            try {
                // Use the password from the lock field if locking now, otherwise use cached password for editing
                const encryptPassword = (password && password.value) ? password.value : editingLockedNote;
                
                // Encrypt the content - reuse existing salt if editing a locked note
                const result = await noteEncryption.encrypt(content.value, encryptPassword, existingSalt || null);
                
                // Create hidden fields for encrypted data
                let encryptedContentField = document.getElementById('encrypted_content');
                let saltField = document.getElementById('salt_field');
                let isLockedField = document.getElementById('is_locked_field');
                
                if (!encryptedContentField) {
                    encryptedContentField = document.createElement('input');
                    encryptedContentField.type = 'hidden';
                    encryptedContentField.name = 'encrypted_content';
                    encryptedContentField.id = 'encrypted_content';
                    this.appendChild(encryptedContentField);
                }
                
                if (!saltField) {
                    saltField = document.createElement('input');
                    saltField.type = 'hidden';
                    saltField.name = 'salt';
                    saltField.id = 'salt_field';
                    this.appendChild(saltField);
                }
                
                if (editingLockedNote && !isLocked) {
                    // When editing an already locked note, ensure is_locked stays true
                    if (!isLockedField) {
                        isLockedField = document.createElement('input');
                        isLockedField.type = 'hidden';
                        isLockedField.name = 'is_locked';
                        isLockedField.id = 'is_locked_field';
                        isLockedField.value = 'on';
                        this.appendChild(isLockedField);
                    }
                }
                
                // Set the encrypted values
                encryptedContentField.value = result.encrypted;
                saltField.value = result.salt;
                
                // Clear the original content field (we'll send encrypted instead)
                content.value = '';
                
                // Clear the password field (don't send password to server)
                if (password) {
                    password.value = '';
                }
                
                // Now submit the form
                this.submit();
            } catch (error) {
                alert('Encryption failed: ' + error.message);
            }
        }
        // If not locked or no password, submit normally
    });

    // Handle editing locked notes - decrypt content on page load
    {% if note and note.is_locked %}
    (async function() {
        const noteData = {
            id: {{ note.pk }},
            content: '{{ note.content }}',
            salt: '{{ note.salt }}',
            is_locked: {{ note.is_locked|lower }}
        };

        // Check if we have a cached password for this note
        const cachedPassword = noteEncryption.getCachedPassword(noteData.id);
        
        if (cachedPassword) {
            try {
                const decryptedContent = await noteEncryption.decrypt(
                    noteData.content,
                    cachedPassword,
                    noteData.salt
                );
                document.getElementById('content').value = decryptedContent;
                // Store the password and salt for re-encryption
                document.getElementById('content').dataset.notePassword = cachedPassword;
                document.getElementById('content').dataset.noteSalt = noteData.salt;
            } catch (error) {
                console.error('Failed to decrypt with cached password:', error);
                // Password might have expired or be wrong, prompt for new one
                promptForPassword();
            }
        } else {
            // No cached password, prompt for it
            promptForPassword();
        }

        async function promptForPassword() {
            const password = prompt('This note is locked. Please enter the password to edit it:');
            if (password) {
                try {
                    const decryptedContent = await noteEncryption.decrypt(
                        noteData.content,
                        password,
                        noteData.salt
                    );
                    document.getElementById('content').value = decryptedContent;
                    // Cache the password for this session
                    noteEncryption.cachePassword(noteData.id, password);
                    
                    // Store the password and salt temporarily for re-encryption
                    document.getElementById('content').dataset.notePassword = password;
                    document.getElementById('content').dataset.noteSalt = noteData.salt;
                } catch (error) {
                    alert('Decryption failed. Wrong password?');
                    window.location.href = '{% url "note_view" note.pk %}';
                }
            } else {
                // User cancelled, redirect back to view
                window.location.href = '{% url "note_view" note.pk %}';
            }
        }
    })();
    {% endif %}
    
    // Tags Management
    (function() {
        const tagsContainer = document.getElementById('tags-container');
        const tagsInput = document.getElementById('tags-input');
        const tagColor = document.getElementById('tag-color');
        const tagsAutocomplete = document.getElementById('tags-autocomplete');
        const tagsData = document.getElementById('tags-data');
        
        let tags = [];
        let autocompleteResults = [];
        let selectedIndex = -1;
        let debounceTimer;
        
        // Load existing tags if editing a note
        {% if note %}
        {% for tag in note.tags.all %}
        tags.push({ name: '{{ tag.name|escapejs }}', color: '{{ tag.color }}' });
        {% endfor %}
        renderTags();
        {% endif %}
        
        function renderTags() {
            tagsContainer.innerHTML = '';
            tags.forEach((tag, index) => {
                const badge = document.createElement('span');
                badge.className = 'tag-badge';
                badge.style.backgroundColor = tag.color;
                badge.innerHTML = `
                    ${tag.name}
                    <span class="tag-remove" onclick="removeTag(${index})">√ó</span>
                `;
                tagsContainer.appendChild(badge);
            });
            updateTagsData();
        }
        
        window.removeTag = function(index) {
            tags.splice(index, 1);
            renderTags();
        };
        
        function updateTagsData() {
            tagsData.value = JSON.stringify(tags);
        }
        
        function addTag(name, color) {
            name = name.trim();
            if (!name) return;
            
            // Check if tag already exists (case-insensitive)
            const exists = tags.some(t => t.name.toLowerCase() === name.toLowerCase());
            if (exists) {
                tagsInput.value = '';
                return;
            }
            
            tags.push({ name, color });
            renderTags();
            tagsInput.value = '';
            hideAutocomplete();
        }
        
        function showAutocomplete(results) {
            if (results.length === 0) {
                hideAutocomplete();
                return;
            }
            
            autocompleteResults = results;
            selectedIndex = -1;
            
            tagsAutocomplete.innerHTML = '';
            results.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-suggestion';
                item.innerHTML = `
                    <span class="tag-suggestion-color" style="background-color: ${tag.color}"></span>
                    <span class="tag-suggestion-name">${tag.name}</span>
                `;
                item.addEventListener('click', () => {
                    addTag(tag.name, tag.color);
                    tagColor.value = tag.color;
                });
                tagsAutocomplete.appendChild(item);
            });
            
            tagsAutocomplete.style.display = 'block';
        }
        
        function hideAutocomplete() {
            tagsAutocomplete.style.display = 'none';
            autocompleteResults = [];
            selectedIndex = -1;
        }
        
        async function fetchAutocomplete(query) {
            try {
                const response = await fetch(`{% url 'tag_autocomplete' %}?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                showAutocomplete(data.results);
            } catch (error) {
                console.error('Failed to fetch autocomplete:', error);
            }
        }
        
        tagsInput.addEventListener('input', (e) => {
            const value = e.target.value;
            
            clearTimeout(debounceTimer);
            
            if (value.trim()) {
                debounceTimer = setTimeout(() => {
                    fetchAutocomplete(value.trim());
                }, 200);
            } else {
                hideAutocomplete();
            }
        });
        
        tagsInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ',') {
                e.preventDefault();
                const value = tagsInput.value.replace(/,\s*$/, '').trim();
                if (value) {
                    if (selectedIndex >= 0 && autocompleteResults[selectedIndex]) {
                        const selected = autocompleteResults[selectedIndex];
                        addTag(selected.name, selected.color);
                        tagColor.value = selected.color;
                    } else {
                        addTag(value, tagColor.value);
                    }
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (autocompleteResults.length > 0) {
                    selectedIndex = Math.min(selectedIndex + 1, autocompleteResults.length - 1);
                    updateSelectedSuggestion();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (autocompleteResults.length > 0) {
                    selectedIndex = Math.max(selectedIndex - 1, 0);
                    updateSelectedSuggestion();
                }
            } else if (e.key === 'Escape') {
                hideAutocomplete();
            }
        });
        
        function updateSelectedSuggestion() {
            const suggestions = tagsAutocomplete.querySelectorAll('.tag-suggestion');
            suggestions.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        // Click outside to close autocomplete
        document.addEventListener('click', (e) => {
            if (!tagsInput.contains(e.target) && !tagsAutocomplete.contains(e.target)) {
                hideAutocomplete();
            }
        });
    })();
</script>
{% endblock %}
