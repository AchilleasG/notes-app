{% extends "base.html" %}
{% load markdown_extras %}
{% load static %}

{% block title %}{{ note.title }} - Personal Notebook{% endblock %}

{% block extra_css %}
<style>
    /* Mobile-first layout */
    .note-view-wrapper {
        max-width: 1200px;
        margin: 0 auto;
    }
    
    /* Quick actions bar at top */
    .quick-actions {
        display: flex;
        gap: 8px;
        margin-bottom: 20px;
        flex-wrap: wrap;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border-primary);
    }
    
    .quick-actions .btn {
        flex: 1;
        min-width: 100px;
    }
    
    @media (min-width: 640px) {
        .quick-actions .btn {
            flex: 0;
        }
    }
    
    /* Notes dropdown for mobile navigation */
    .notes-nav {
        margin-bottom: 20px;
    }
    
    .notes-dropdown {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 15px;
        font-family: inherit;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .notes-dropdown:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px var(--accent-light);
    }
    
    /* Main content */
    .note-view-container {
        background: var(--bg-secondary);
        border-radius: 12px;
        padding: 20px;
        border: 1px solid var(--border-primary);
    }
    
    @media (min-width: 640px) {
        .note-view-container {
            padding: 32px;
        }
    }
    
    .note-header {
        margin-bottom: 24px;
        padding-bottom: 20px;
        border-bottom: 1px solid var(--border-secondary);
    }
    
    .note-title {
        color: var(--text-primary);
        font-size: 24px;
        font-weight: 600;
        margin-bottom: 12px;
        word-wrap: break-word;
        line-height: 1.3;
    }
    
    @media (min-width: 640px) {
        .note-title {
            font-size: 28px;
        }
    }
    
    .note-title .lock-badge {
        font-size: 20px;
        margin-right: 6px;
    }
    
    .note-meta {
        font-size: 13px;
        color: var(--text-tertiary);
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }
    
    /* Note tags */
    .note-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--border-secondary);
    }
    
    .note-tag {
        display: inline-block;
        padding: 6px 14px;
        border-radius: 16px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: opacity 0.2s;
        text-decoration: none;
    }
    
    .note-tag:hover {
        opacity: 0.85;
    }
    
    .note-content {
        padding: 0;
        margin-bottom: 24px;
        line-height: 1.7;
        color: var(--text-primary);
        font-size: 16px;
    }
    
    /* Markdown content styling */
    .note-content h1, .note-content h2, .note-content h3, 
    .note-content h4, .note-content h5, .note-content h6 {
        margin-top: 24px;
        margin-bottom: 12px;
        font-weight: 600;
        color: var(--text-primary);
        line-height: 1.3;
    }
    
    .note-content h1 { 
        font-size: 24px; 
        border-bottom: 1px solid var(--border-secondary); 
        padding-bottom: 10px; 
    }
    
    .note-content h2 { 
        font-size: 21px; 
        border-bottom: 1px solid var(--border-secondary); 
        padding-bottom: 8px; 
    }
    
    .note-content h3 { font-size: 18px; }
    .note-content h4 { font-size: 16px; }
    
    .note-content ul, .note-content ol {
        margin-left: 20px;
        margin-bottom: 16px;
    }
    
    .note-content li {
        margin-bottom: 6px;
    }
    
    .note-content p {
        margin-bottom: 16px;
    }
    
    /* Task list styling */
    .note-content .task-list-item {
        list-style: none;
        margin-left: -20px;
    }
    
    .note-content .task-list-item input[type="checkbox"] {
        margin-right: 8px;
        cursor: pointer;
        width: 16px;
        height: 16px;
    }
    
    .note-content .task-list-item:has(input[type="checkbox"]:checked) {
        text-decoration: line-through;
        opacity: 0.6;
    }
    
    /* Table styling */
    .note-content table {
        border-collapse: collapse;
        width: 100%;
        margin: 16px 0;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        overflow: hidden;
        font-size: 15px;
    }
    
    .note-content th, .note-content td {
        border: 1px solid var(--border-primary);
        padding: 10px 12px;
        text-align: left;
    }
    
    .note-content th {
        background: var(--bg-tertiary);
        font-weight: 600;
    }
    
    .note-content img {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        margin: 16px 0;
    }
    
    /* Code styling */
    .note-content code {
        background: var(--bg-tertiary);
        padding: 3px 6px;
        border-radius: 4px;
        font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 0.9em;
    }
    
    .note-content pre {
        background: var(--bg-tertiary);
        padding: 16px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 16px 0;
        font-size: 14px;
        border: 1px solid var(--border-primary);
    }
    
    .note-content pre code {
        background: transparent;
        padding: 0;
    }
    
    .note-content blockquote {
        border-left: 4px solid var(--accent-primary);
        padding-left: 16px;
        margin: 16px 0;
        color: var(--text-secondary);
        font-style: italic;
    }
    
    .note-content a {
        color: var(--accent-primary);
        text-decoration: underline;
        text-underline-offset: 2px;
    }
    
    .note-content a:hover {
        color: var(--accent-hover);
    }
    
    /* Note actions */
    .note-actions {
        display: flex;
        gap: 8px;
        padding-top: 20px;
        border-top: 1px solid var(--border-secondary);
        flex-wrap: wrap;
    }
    
    .note-actions .btn {
        flex: 1;
        min-width: 100px;
    }
    
    @media (min-width: 640px) {
        .note-actions .btn {
            flex: 0;
        }
    }
    
    /* Password modal */
    .password-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: 20px;
    }
    
    .password-modal.hidden {
        display: none;
    }
    
    .password-modal-content {
        background: var(--bg-secondary);
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 10px 40px var(--shadow-lg);
        max-width: 400px;
        width: 100%;
    }
    
    .password-modal h3 {
        margin: 0 0 16px 0;
        color: var(--text-primary);
        font-size: 18px;
        font-weight: 600;
    }
    
    .password-input {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        font-size: 16px;
        margin-bottom: 16px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-family: inherit;
    }
    
    .password-input:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px var(--accent-light);
    }
    
    .password-buttons {
        display: flex;
        gap: 8px;
    }
    
    .password-buttons .btn {
        flex: 1;
    }
    
    .encrypted-placeholder {
        background: var(--bg-tertiary);
        border: 2px dashed var(--border-primary);
        border-radius: 12px;
        padding: 40px 20px;
        text-align: center;
        margin: 20px 0;
    }
    
    .encrypted-placeholder .lock-icon {
        font-size: 48px;
        margin-bottom: 16px;
        display: block;
        opacity: 0.6;
    }
    
    .encrypted-placeholder h3 {
        color: var(--text-primary);
        font-size: 18px;
        margin-bottom: 8px;
    }
    
    .encrypted-placeholder p {
        color: var(--text-secondary);
        margin-bottom: 16px;
    }
    
    /* === SIDEBAR === */
    .notes-sidebar {
        position: fixed;
        top: 0;
        left: -320px;
        width: 320px;
        height: 100vh;
        background: var(--bg-secondary);
        border-right: 1px solid var(--border-primary);
        box-shadow: 2px 0 12px rgba(0,0,0,0.1);
        transition: left 0.3s ease;
        z-index: 9999;
        overflow-y: auto;
        padding: 16px;
    }
    
    .notes-sidebar.open {
        left: 0;
    }
    
    .sidebar-header-title {
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 16px;
        color: var(--text-primary);
    }
    
    .sidebar-note-link {
        display: block;
        padding: 12px;
        margin-bottom: 8px;
        border-radius: 8px;
        text-decoration: none;
        color: var(--text-primary);
        background: var(--bg-tertiary);
        transition: all 0.2s;
    }
    
    .sidebar-note-link:hover {
        background: var(--border-primary);
    }
    
    .sidebar-note-link.active {
        background: var(--accent-primary);
        color: white;
    }
    
    .sidebar-note-title {
        font-weight: 500;
        margin-bottom: 4px;
    }
    
    .sidebar-note-date {
        font-size: 12px;
        color: var(--text-tertiary);
    }
    
    .sidebar-toggle-btn {
        position: fixed;
        bottom: 24px;
        left: 24px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: var(--accent-primary);
        color: white;
        border: none;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 9998;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }
    
    .sidebar-toggle-btn:hover {
        transform: scale(1.1);
    }
    
    .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 9997;
        display: none;
    }
    
    .sidebar-overlay.active {
        display: block;
    }
</style>
{% endblock %}

{% block content %}
<div class="note-view-wrapper">
    <!-- Quick actions at top -->
    <div class="quick-actions">
        <a href="{% url 'note_list' %}" class="btn btn-secondary">‚Üê All Notes</a>
        <a href="{% url 'note_create' %}" class="btn btn-primary">+ New</a>
        <a href="{% url 'note_edit' note.pk %}" class="btn btn-primary">Edit</a>
        <a href="{% url 'note_delete' note.pk %}" class="btn btn-danger">Delete</a>
    </div>
    
    <!-- Navigation dropdown for switching between notes -->
    <div class="notes-nav">
        <select class="notes-dropdown" onchange="if(this.value) window.location.href=this.value;">
            <option value="">Switch to another note...</option>
            {% for n in all_notes %}
                <option value="{% url 'note_view' n.pk %}" {% if n.pk == note.pk %}selected{% endif %}>
                    {% if n.is_locked %}üîí {% endif %}{{ n.title|truncatechars:50 }}
                </option>
            {% endfor %}
        </select>
    </div>
    
    <!-- Main note content -->
    <div class="note-view-container">
        <div class="note-header">
            <h1 class="note-title">
                {% if note.is_locked %}<span class="lock-badge">üîí</span>{% endif %}
                {{ note.title }}
            </h1>
            <div class="note-meta">
                <span>Created {{ note.created_at|date:"M d, Y" }}</span>
                {% if note.updated_at != note.created_at %}
                    <span>‚Ä¢ Updated {{ note.updated_at|date:"M d, Y" }}</span>
                {% endif %}
            </div>
            {% if note.tags.all %}
                <div class="note-tags">
                    {% for tag in note.tags.all %}
                        <a href="{% url 'note_list' %}?tags={{ tag.name|urlencode }}" 
                           class="note-tag" 
                           style="background-color: {{ tag.color }}; color: {{ tag.color|text_color_for_bg }}">
                            {{ tag.name }}
                        </a>
                    {% endfor %}
                </div>
            {% endif %}
        </div>
        
        <div id="noteContent" class="note-content">
            {% if note.note_type == 'canvas' %}
                <!-- Canvas Note Content -->
                {% include "notes/canvas_editor_partial.html" with note_id=note.pk elements_json=elements_json csrf_token=csrf_token %}
            {% elif note.is_locked %}
                <div class="encrypted-placeholder">
                    <span class="lock-icon">üîí</span>
                    <h3>This note is encrypted</h3>
                    <p>Enter your password to decrypt and view the content.</p>
                    <button class="btn btn-primary" onclick="showPasswordModal()">
                        üîì Decrypt Note
                    </button>
                </div>
            {% else %}
                <!-- Markdown content will be rendered client-side -->
            {% endif %}
        </div>
        
        <div class="note-actions">
            <a href="{% url 'note_history' note.pk %}" class="btn btn-secondary">üìú History</a>
        </div>
    </div>
</div>

<!-- Sidebar -->
<div class="notes-sidebar" id="notesSidebar">
    <div class="sidebar-header-title">üìö All Notes</div>
    {% for n in all_notes %}
        <a href="{% url 'note_view' n.pk %}" class="sidebar-note-link {% if n.pk == note.pk %}active{% endif %}">
            <div class="sidebar-note-title">
                {% if n.is_locked %}üîí {% endif %}{{ n.title|truncatechars:40 }}
            </div>
            <div class="sidebar-note-date">{{ n.updated_at|date:"M d, Y" }}</div>
        </a>
    {% endfor %}
</div>

<!-- Sidebar Overlay -->
<div class="sidebar-overlay" id="sidebarOverlay"></div>

<!-- Toggle Button -->
<button class="sidebar-toggle-btn" id="sidebarToggleBtn" aria-label="Toggle sidebar">
    ‚ò∞
</button>

<!-- Password Modal -->
<div id="passwordModal" class="password-modal hidden">
    <div class="password-modal-content">
        <h3>üîí Enter Password</h3>
        <input type="password" id="passwordInput" class="password-input" placeholder="Enter password to decrypt note" />
        <div class="password-buttons">
            <button class="btn btn-secondary" onclick="hidePasswordModal()">Cancel</button>
            <button class="btn btn-primary" onclick="decryptNote()">Decrypt</button>
        </div>
    </div>
</div>

<!-- CSRF Token for AJAX requests -->
{% csrf_token %}

<!-- Load marked.js for client-side markdown rendering -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<!-- Load our markdown renderer and checkbox handler -->
<script src="{% static 'js/markdown-renderer.js' %}"></script>
<script src="{% static 'js/checkbox-handler.js' %}"></script>

<script>
/**
 * Client-side encryption/decryption for notes
 * Uses Web Crypto API for secure encryption
 */
class NoteEncryption {
    constructor() {
        // Store passwords in memory only (cleared on page refresh)
        this.passwordCache = new Map();
        this.algorithm = 'AES-GCM';
        this.keyLength = 256;
        this.ivLength = 12; // 96 bits for AES-GCM
        this.saltLength = 16; // 128 bits
        this.iterations = 100000; // PBKDF2 iterations
    }

    /**
     * Generate a random salt
     */
    generateSalt() {
        return crypto.getRandomValues(new Uint8Array(this.saltLength));
    }

    /**
     * Generate a random IV
     */
    generateIV() {
        return crypto.getRandomValues(new Uint8Array(this.ivLength));
    }

    /**
     * Derive a key from password and salt using PBKDF2
     */
    async deriveKey(password, salt) {
        const encoder = new TextEncoder();
        const passwordKey = await crypto.subtle.importKey(
            'raw',
            encoder.encode(password),
            'PBKDF2',
            false,
            ['deriveKey']
        );

        return crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: salt,
                iterations: this.iterations,
                hash: 'SHA-256'
            },
            passwordKey,
            {
                name: this.algorithm,
                length: this.keyLength
            },
            false,
            ['encrypt', 'decrypt']
        );
    }

    /**
     * Encrypt text with password
     */
    async encrypt(text, password) {
        try {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            
            const salt = this.generateSalt();
            const iv = this.generateIV();
            const key = await this.deriveKey(password, salt);

            const encryptedData = await crypto.subtle.encrypt(
                {
                    name: this.algorithm,
                    iv: iv
                },
                key,
                data
            );

            // Combine only iv + encrypted data (salt stored separately)
            const result = new Uint8Array(iv.length + encryptedData.byteLength);
            result.set(iv, 0);
            result.set(new Uint8Array(encryptedData), iv.length);

            // Return base64 encoded result and salt as hex for storage
            return {
                encrypted: btoa(String.fromCharCode(...result)),
                salt: Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('')
            };
        } catch (error) {
            console.error('Encryption failed:', error);
            throw new Error('Failed to encrypt content');
        }
    }

    /**
     * Decrypt text with password
     */
    async decrypt(encryptedText, password, saltHex) {
        try {
            // Convert base64 back to bytes
            const combined = new Uint8Array(atob(encryptedText).split('').map(c => c.charCodeAt(0)));
            
            // Extract salt from hex (stored separately in database)
            const salt = new Uint8Array(saltHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
            
            // Try to determine the format based on the length
            let iv, encryptedData;
            
            if (combined.length >= this.saltLength + this.ivLength) {
                // Check if this might be the old format (salt + iv + data)
                // Extract the first saltLength bytes and see if they match our stored salt
                const embeddedSalt = combined.slice(0, this.saltLength);
                const saltMatches = Array.from(embeddedSalt).every((byte, i) => byte === salt[i]);
                
                if (saltMatches) {
                    // Old format: salt + iv + encrypted data
                    console.log('Detected old format with embedded salt');
                    iv = combined.slice(this.saltLength, this.saltLength + this.ivLength);
                    encryptedData = combined.slice(this.saltLength + this.ivLength);
                } else {
                    // New format: iv + encrypted data
                    console.log('Detected new format without embedded salt');
                    iv = combined.slice(0, this.ivLength);
                    encryptedData = combined.slice(this.ivLength);
                }
            } else {
                // New format: iv + encrypted data
                console.log('Detected new format based on length');
                iv = combined.slice(0, this.ivLength);
                encryptedData = combined.slice(this.ivLength);
            }

            const key = await this.deriveKey(password, salt);

            const decryptedData = await crypto.subtle.decrypt(
                {
                    name: this.algorithm,
                    iv: iv
                },
                key,
                encryptedData
            );

            const decoder = new TextDecoder();
            return decoder.decode(decryptedData);
        } catch (error) {
            console.error('Decryption failed:', error);
            throw new Error('Failed to decrypt content - wrong password?');
        }
    }

    /**
     * Cache password for a note
     */
    cachePassword(noteId, password) {
        this.passwordCache.set(noteId, password);
    }

    /**
     * Get cached password for a note
     */
    getCachedPassword(noteId) {
        return this.passwordCache.get(noteId);
    }

    /**
     * Clear cached password for a note
     */
    clearCachedPassword(noteId) {
        this.passwordCache.delete(noteId);
    }

    /**
     * Clear all cached passwords
     */
    clearAllPasswords() {
        this.passwordCache.clear();
    }
}

// Global instance
window.noteEncryption = new NoteEncryption();

// Clear passwords when page is about to unload
window.addEventListener('beforeunload', () => {
    window.noteEncryption.clearAllPasswords();
});
</script>

<script>
console.log('Script starting to load...');

// Note data from server
const noteData = {
    id: {{ note.pk }},
    title: "{{ note.title|escapejs }}",
    content: "{{ note.content|escapejs }}",
    noteType: "{{ note.note_type }}",
    isLocked: {{ note.is_locked|yesno:"true,false" }},
    salt: "{{ note.salt|default:"" }}",
    createdAt: "{{ note.created_at.isoformat|escapejs }}",
    updatedAt: "{{ note.updated_at.isoformat|escapejs }}"
};

// Track the current working content (for encrypted notes, this will be the decrypted content)
let currentWorkingContent = noteData.content;

console.log('Note data:', noteData);

// Global functions for modal and decryption
window.showPasswordModal = function() {
    console.log('showPasswordModal called');
    document.getElementById('passwordModal').classList.remove('hidden');
    document.getElementById('passwordInput').focus();
}

window.hidePasswordModal = function() {
    console.log('hidePasswordModal called');
    document.getElementById('passwordModal').classList.add('hidden');
    document.getElementById('passwordInput').value = '';
}

window.decryptNote = async function() {
    console.log('decryptNote called');
    const password = document.getElementById('passwordInput').value;
    
    if (!password) {
        alert('Please enter a password');
        return;
    }

    try {
        console.log('Attempting to decrypt...');
        const decryptedContent = await window.noteEncryption.decrypt(
            noteData.content, 
            password, 
            noteData.salt
        );
        
        console.log('Decryption successful');
        
        // Store the decrypted content as the current working content
        currentWorkingContent = decryptedContent;
        
        // Cache the password for this session
        window.noteEncryption.cachePassword(noteData.id, password);
        
        // Update the content display - use server-side rendering for consistency
        const contentDiv = document.getElementById('noteContent');
        await renderDecryptedContent(decryptedContent, contentDiv);
        
        // Hide the modal
        hidePasswordModal();
        
        // Re-initialize checkbox handlers for the new content with a small delay
        setTimeout(() => {
            console.log('Reinitializing checkbox handlers after decryption');
            initializeCheckboxHandlers();
        }, 50);
        
    } catch (error) {
        console.error('Decryption error:', error);
        alert('Decryption failed: ' + error.message);
        document.getElementById('passwordInput').value = '';
        document.getElementById('passwordInput').focus();
    }
}

async function decryptNoteWithPassword(password) {
    try {
        console.log('Auto-decrypting with cached password...');
        const decryptedContent = await window.noteEncryption.decrypt(
            noteData.content, 
            password, 
            noteData.salt
        );
        
        // Store the decrypted content as the current working content
        currentWorkingContent = decryptedContent;
        
        // Update the content display - use server-side rendering for consistency
        const contentDiv = document.getElementById('noteContent');
        await renderDecryptedContent(decryptedContent, contentDiv);
        
        // Re-initialize checkbox handlers for the new content with a small delay
        setTimeout(() => {
            console.log('Reinitializing checkbox handlers after auto-decryption');
            initializeCheckboxHandlers();
        }, 50);
        
    } catch (error) {
        console.error('Auto-decrypt failed:', error);
        // If auto-decrypt fails, clear the cached password
        window.noteEncryption.clearCachedPassword(noteData.id);
    }
}

async function renderDecryptedContent(markdownContent, contentDiv) {
    // Client-side markdown rendering - no server communication
    if (typeof window.markdownRenderer !== 'undefined') {
        const html = window.markdownRenderer.render(markdownContent, true); // true = interactive checkboxes
        contentDiv.innerHTML = html;
    } else {
        // Fallback if renderer not loaded
        contentDiv.innerHTML = '<pre>' + markdownContent + '</pre>';
    }
}

function initializeCheckboxHandlers() {
    console.log('initializeCheckboxHandlers called');
    
    // Initialize the checkbox handler with note configuration
    if (typeof window.checkboxHandler !== 'undefined') {
        const password = noteData.isLocked ? window.noteEncryption.getCachedPassword(noteData.id) : null;
        
        window.checkboxHandler.init({
            content: currentWorkingContent,
            noteId: noteData.id,
            noteType: 'regular',
            isEncrypted: noteData.isLocked,
            encryptionPassword: password,
            encryptionSalt: noteData.salt,
            updateUrl: `/edit/${noteData.id}/`,
            csrfToken: document.querySelector('[name=csrfmiddlewaretoken]').value,
            onContentUpdate: (updatedContent) => {
                // Update our local content reference
                currentWorkingContent = updatedContent;
                console.log('Content updated via checkbox');
            }
        });
        
        console.log('Checkbox handler initialized');
    } else {
        console.error('Checkbox handler not loaded');
    }
}

document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing...');
    
    // Skip markdown rendering for canvas notes
    if (noteData.noteType === 'canvas') {
        console.log('Canvas note detected, skipping markdown rendering');
        return;
    }
    
    // Check if noteEncryption is available
    if (typeof window.noteEncryption === 'undefined') {
        console.error('noteEncryption not loaded!');
    } else {
        console.log('noteEncryption loaded successfully');
    }

    // Initialize checkbox handlers if note is not locked or auto-decrypt if password is cached
    if (!noteData.isLocked) {
        console.log('Note is not locked, rendering content client-side');
        
        // Render the content client-side
        const contentDiv = document.getElementById('noteContent');
        if (window.markdownRenderer && contentDiv && typeof marked !== 'undefined') {
            try {
                const html = window.markdownRenderer.render(noteData.content, true); // true = interactive checkboxes
                contentDiv.innerHTML = html;
            } catch (error) {
                console.error('Failed to render content:', error);
                contentDiv.innerHTML = '<pre>' + noteData.content + '</pre>';
            }
        } else if (contentDiv) {
            console.error('Markdown renderer or marked.js not available');
            contentDiv.innerHTML = '<pre>' + noteData.content + '</pre>';
        }
        
        // Initialize checkbox handlers
        setTimeout(() => {
            initializeCheckboxHandlers();
        }, 100);
    } else {
        console.log('Note is locked, checking for cached password');
        // Check if we have a cached password
        const cachedPassword = window.noteEncryption ? window.noteEncryption.getCachedPassword(noteData.id) : null;
        if (cachedPassword) {
            console.log('Found cached password, auto-decrypting');
            decryptNoteWithPassword(cachedPassword);
        } else {
            console.log('No cached password found');
        }
    }
    
    // Handle Enter key in password modal
    const passwordInput = document.getElementById('passwordInput');
    if (passwordInput) {
        passwordInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                decryptNote();
            }
        });
    }
    
    // === SIDEBAR FUNCTIONALITY ===
    const sidebar = document.getElementById('notesSidebar');
    const sidebarToggle = document.getElementById('sidebarToggleBtn');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    
    function openSidebar() {
        sidebar.classList.add('open');
        sidebarOverlay.classList.add('active');
        sidebarToggle.textContent = '‚úï';
    }
    
    function closeSidebar() {
        sidebar.classList.remove('open');
        sidebarOverlay.classList.remove('active');
        sidebarToggle.textContent = '‚ò∞';
    }
    
    sidebarToggle.addEventListener('click', function() {
        if (sidebar.classList.contains('open')) {
            closeSidebar();
        } else {
            openSidebar();
        }
    });
    
    sidebarOverlay.addEventListener('click', closeSidebar);
    
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && sidebar.classList.contains('open')) {
            closeSidebar();
        }
    });
});

console.log('Script loaded, functions defined');
</script>
{% endblock %}
